-----------------Creating Simple Views-------------
--One table, no functions, no group, allow dml OPERATIONS
drop view emp_v1;

create view emp_v1
AS
select EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID
from EMPLOYEES;

select * from emp_v1;



---Data Dictionary Table
select * from USER_VIEWS
where view_name='EMP_V1';

select * from ALL_VIEWS;



--You can do describe on a view
desc emp_v1;


--I can do dml operations on this
commit;

insert into emp_v1(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
            values(333, 'David', 'Fish', 'dfish', sysdate, 'IT_PROG');


select * from emp_v1;

select * from EMPLOYEES;


drop table test;

create table test(
        test_id number primary key,
        test_name varchar2(20) not null,
        test_date date,
        test_type varchar2(1)
);

-- Inserting records into the test table
INSERT INTO test (test_id, test_name, test_date, test_type)
VALUES (1, 'Test 1', TO_DATE('2023-07-04', 'YYYY-MM-DD'), 'A');

INSERT INTO test (test_id, test_name, test_date, test_type)
VALUES (2, 'Test 2', TO_DATE('2023-06-30', 'YYYY-MM-DD'), 'B');

INSERT INTO test (test_id, test_name, test_date, test_type)
VALUES (3, 'Test 3', TO_DATE('2023-07-02', 'YYYY-MM-DD'), 'A');

INSERT INTO test (test_id, test_name, test_date, test_type)
VALUES (4, 'Test 4', TO_DATE('2023-07-01', 'YYYY-MM-DD'), 'B');

INSERT INTO test (test_id, test_name, test_date, test_type)
VALUES (5, 'Test 5', TO_DATE('2023-07-03', 'YYYY-MM-DD'), 'A');


create view test_vw AS
select test_id,test_date, test_type from test;

--Je kan obviously niet inserten in je view, omdat je in je table een non null column hebt en in je view heb je die column niet opgenonmen
select * from test_vw;
insert into test_vw(test_id, test_date, test_type)values(6, sysdate, 'A');




---Simple view v2


--Als je het zo doet dan heb je je eigen kolumn header things
create view emp_v2
as 
select EMPLOYEE_ID emp_id, FIRST_NAME fname, LAST_NAME lname, EMAIL, HIRE_DATE, JOB_ID
from EMPLOYEES;

select * from emp_v2;

--so when doing dml becomes this:
insert into emp_v2(emp_id, fname, lname, email, HIRE_DATE, JOB_ID)
VALUES              (444, 'Sameer', 'Kewal', 'skewal', sysdate, 'IT_PROG');


--If you try to insert using the original column headers dan gaat het niet
insert into emp_v2(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
VALUES              (555, 'Jasmine', 'de Vries', 'jdevries', sysdate, 'IT_PROG');

select * from EMPLOYEES;


------Another way om die alias namen ig te specifyen is this:

create view emp_v3(empid, fnmame, lname, mail, hiredate, job)
as
select EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID
from EMPLOYEES;

--Ook hier kan je obviously niet zo inserten
insert into emp_v3(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, job)
VALUES              (555, 'Gaby', 'WOman', 'Gwoman', sysdate, 'IT_PROG');


create view emp_v3(empid, fnmame, lname, mail, hiredate, job)
as
select EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID
from EMPLOYEES;


--Je mag in je subquery aliasses hebben maar die kolumn header gaat nog steeds zijn van wat je hebt bij je create view statement
create view emp_v4(empid, fname, lname, male, hiredate, job)
as
select EMPLOYEE_ID eee, FIRST_NAME, LAST_NAME, EMAIL,HIRE_DATE, JOB_ID
from EMPLOYEES;

select * from emp_v4;


--creating a view with constraints
--Kan alleen in disabled mode
drop view emp_v5;


create view emp_v5
(
    empid unique disable,
    FIRST_NAME
)
as
select EMPLOYEE_ID, FIRST_NAME from EMPLOYEES;


drop view emp_v5;
create view emp_v5
(
    empid primary key disable,
    FIRST_NAME
)
as
select EMPLOYEE_ID, FIRST_NAME from EMPLOYEES;

--Alleen column level constraints
drop view emp_v5;
create view emp_v5
(
    empid primary key disable,
    FIRST_NAME,
    departments references departments(DEPARTMENT_ID) disable novalidate
)
as
select EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID from EMPLOYEES;

--JE KAN TABLE LEVEL CONSTRAINTS ZETTEN 
drop table emp_v5;
create view emp_v5
(
    empid,
    FIRST_NAME,
    departmentss,
    constraint emp_id_pk primary key(empid) disable
)
as
select EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID from EMPLOYEES;

--TABLE LEVEL CONSTRAINTS
drop view emp_v1;
create view EMP_V1(
    FNAME,
    LNAME,
    dept_id,
    CONSTRAINT fk_emp_deptid FOREIGN KEY (dept_id) REFERENCES departments(DEPARTMENT_ID) disable
)
as select FIRST_NAME, LAST_NAME, DEPARTMENT_ID from EMPLOYEES;




--Alter views
alter view emp_v5 add constraint emp_v5_unique unique(FIRST_NAME);
alter view emp_v5 drop constraint emp_v5_unique;


--Data dictionary om je view constraints te vinden
select * from USER_CONSTRAINTS where table_name = 'EMP_V5';

drop table test;

create table test(
    test_id number generated by default on null as identity,
    test_name varchar2(20) constraint test_chk check(length(test_name)>3),
    test_dept number,
    constraint test_fk foreign key(test_dept) references departments
);

drop view v1;

create view v1(
    v1_id constraint v1_chk check(v1_id>0) disable NOVALIDATE
)
as select EMPLOYEE_ID
from employees;






